-- Assignment 2 ETL: ft_param_city_month
-- GRAIN: month_key × city_key × param_key

-- EXAMPLE SHAPE (sketch only):
-- TRUNCATE TABLE ft_param_city_month;
-- WITH cte1 AS (...),
--      cte2 AS (...),
--      cte3 AS (...),
--      ... AS (...),
--      final_cte AS (...)
-- INSERT INTO ft_param_city_month (...columns...)
-- SELECT ... FROM final_cte;

-- Assignment 2 ETL: ft_param_city_month
-- GRAIN: month_key x city_key x param_key
-- Source: stg2_033 (tb_readingevent, tb_sensordevice, tb_city, tb_paramalert, tb_alert)
-- Target: dwh2_033.ft_param_city_month

SET search_path TO dwh2_033, stg2_033;

-- =======================================
-- Load ft_param_city_month
-- =======================================

TRUNCATE TABLE ft_param_city_month RESTART IDENTITY CASCADE;

INSERT INTO ft_param_city_month (
    ft_pcm_key,
    month_key,
    city_key,
    param_key,
    alertpeak_key,
    reading_events_count,
    devices_reporting_count,
    recordedvalue_avg,
    recordedvalue_p95,
    exceed_days_any,
    data_volume_kb_sum,
    data_quality_avg,
    missing_days
)
WITH 
-- 1. Base Readings joined with context (City, Param, Date)
raw_readings AS (
    SELECT 
        re.id AS reading_id,
        re.sensordevid,
        re.readat,
        TO_CHAR(re.readat, 'YYYYMM')::INT AS month_key,
        sd.cityid, -- Matches stg2_033.tb_city.id
        re.paramid, -- Matches stg2_033.tb_param.id
        re.recordedvalue,
        re.datavolumekb,
        re.dataquality
    FROM tb_readingevent re
    JOIN tb_sensordevice sd ON re.sensordevid = sd.id
),

-- 2. Daily Alert Calculations
-- Determine the alert level for every reading by checking thresholds.
-- Then aggregate to the Max Rank per Day (Daily Peak).
daily_alerts AS (
    SELECT
        rr.cityid,
        rr.paramid,
        rr.readat,
        -- Calculate the max alert rank for this specific day/city/param
        MAX(
            CASE 
                -- If reading exceeds threshold, map the Alert Name to a Rank (1..4)
                WHEN rr.recordedvalue >= pa.threshold THEN 
                    CASE 
                        WHEN a.alertname ILIKE '%%Yellow%%' THEN 1
                        WHEN a.alertname ILIKE '%%Orange%%' THEN 2
                        WHEN a.alertname ILIKE '%%Red%%' THEN 3 
                        WHEN a.alertname ILIKE '%%Crimson%%' THEN 4
                        ELSE 0 
                    END
                ELSE 0 
            END
        ) AS daily_rank
    FROM raw_readings rr
    LEFT JOIN tb_paramalert pa ON rr.paramid = pa.paramid
    LEFT JOIN tb_alert a ON pa.alertid = a.id
    GROUP BY rr.cityid, rr.paramid, rr.readat
),

-- 3. Monthly Aggregations (Measures)
monthly_aggs AS (
    SELECT
        rr.month_key,
        rr.cityid,
        rr.paramid,
        
        -- Measures: Counts and Sums
        COUNT(DISTINCT (rr.sensordevid, rr.readat)) AS reading_events_count,
        COUNT(DISTINCT rr.sensordevid) AS devices_reporting_count,
        SUM(rr.datavolumekb) AS data_volume_kb_sum,
        
        -- Measures: Averages and Percentiles
        AVG(rr.recordedvalue) AS recordedvalue_avg,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY rr.recordedvalue) AS recordedvalue_p95,
        AVG(rr.dataquality) AS data_quality_avg,
        
        -- Distinct reading days (needed for missing_days calculation)
        COUNT(DISTINCT rr.readat) AS days_with_readings
        
    FROM raw_readings rr
    GROUP BY rr.month_key, rr.cityid, rr.paramid
),

-- 4. Monthly Alert Aggregations
-- Aggregating the daily ranks calculated in CTE 2
monthly_alert_stats AS (
    SELECT 
        TO_CHAR(readat, 'YYYYMM')::INT AS month_key,
        cityid,
        paramid,
        -- exceed_days_any: Count of days where daily peak alert reached at least Yellow (Rank >= 1)
        COUNT(CASE WHEN daily_rank >= 1 THEN 1 END) AS exceed_days_any,
        -- monthly_peak_rank: The highest daily rank occurring in the month
        MAX(daily_rank) AS max_monthly_rank
    FROM daily_alerts
    GROUP BY TO_CHAR(readat, 'YYYYMM')::INT, cityid, paramid
)

-- 5. Final Join to Dimensions and Calculation of Keys
SELECT 
    -- Surrogate PK (generated by sequence/identity, but mapped here if needed, or allow auto-gen)
    -- Since target has generated identity for PK, we usually omit it in INSERT list if it's SERIAL, 
    -- but here we map explicitly to the columns provided in the INSERT statement.
    -- However, the ID is not generated in the CTEs. 
    -- Note: The DDL defines ft_pcm_key as INT NOT NULL PRIMARY KEY (not serial/identity in the provided DDL?).
    -- CHECK DDL: "ft_pcm_key INT NOT NULL PRIMARY KEY". It does NOT say GENERATED ALWAYS.
    -- We must generate a key. Row_Number is a safe bet for a full reload.
    ROW_NUMBER() OVER (ORDER BY ma.month_key, ma.cityid, ma.paramid) AS ft_pcm_key,
    
    ma.month_key,
    
    dc.city_key,
    dp.param_key,
    
    -- alertpeak_key: Map 0..4 to 1000..1004
    (1000 + COALESCE(mas.max_monthly_rank, 0)) AS alertpeak_key,
    
    ma.reading_events_count,
    ma.devices_reporting_count,
    ROUND(ma.recordedvalue_avg, 6),
    ROUND(ma.recordedvalue_p95::numeric, 6),
    
    COALESCE(mas.exceed_days_any, 0) AS exceed_days_any,
    ma.data_volume_kb_sum,
    ROUND(ma.data_quality_avg, 6),
    
    -- missing_days: days_in_month - days_with_readings
    (dt.days_in_month - ma.days_with_readings) AS missing_days

FROM monthly_aggs ma
-- Join Alert Stats
LEFT JOIN monthly_alert_stats mas 
    ON ma.month_key = mas.month_key 
    AND ma.cityid = mas.cityid 
    AND ma.paramid = mas.paramid

-- Join Dimensions to get Surrogate Keys
-- Note: We must join on Natural Keys (Name/Country) because IDs might differ between systems,
-- though usually in this lab setup, we trust the lookup logic.
-- Dimension: Time (to get days_in_month)
JOIN dim_timemonth dt ON ma.month_key = dt.month_key

-- Dimension: City (Join via Staging IDs -> Names -> Dim Keys)
JOIN tb_city stg_c ON ma.cityid = stg_c.id
JOIN tb_country stg_co ON stg_c.countryid = stg_co.id
JOIN dim_city dc 
    ON dc.city_name = stg_c.cityname 
    AND dc.country_name = stg_co.countryname

-- Dimension: Param (Join via Staging IDs -> Names -> Dim Keys)
JOIN tb_param stg_p ON ma.paramid = stg_p.id
JOIN dim_param dp ON dp.param_name = stg_p.paramname;